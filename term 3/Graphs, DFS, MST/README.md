# Графы, DFS, MST

## A. Топологическая сортировка

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан ориентированный невзвешенный граф. Необходимо его топологически отсортировать.

### Входные данные

В первой строке входного файла даны два натуральных числа _N_ и _M_ (1 ≤ _N_ ≤ 100 000, 0 ≤ _M_ ≤ 100 000) — количество вершин и рёбер в графе соответственно. Далее в _M_ строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.
### Выходные данные

Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.

### Примеры

**входные данные**
```c++
6 6
1 2
3 2
4 2
2 5
6 5
4 6
```
**выходные данные**
```c++
4 6 3 1 2 5 
```

### [Решение](A.cpp)


## B. Мосты

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан неориентированный граф, не обязательно связный, но не содержащий петель и кратных рёбер. Требуется найти все мосты в нём.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количества вершин и рёбер графа соответственно (1 ≤ _n_ ≤ 20 000, 1 ≤ _m_ ≤ 200 000).

Следующие _m_ строк содержат описание рёбер по одному на строке. Ребро номер _i_ описывается двумя натуральными числами _bi_, _ei_ — номерами концов ребра (1 ≤ _bi_, _ei_ ≤ _n_).

### Выходные данные

Первая строка выходного файла должна содержать одно натуральное число _b_ — количество мостов в заданном графе. На следующей строке выведите _b_ целых чисел — номера рёбер, которые являются мостами, в возрастающем порядке. Рёбра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

### Примеры

**входные данные**
```c++
6 7
1 2
2 3
3 4
1 3
4 5
4 6
5 6
```
**выходные данные**
```c++
1
3
```

### [Решение](B.cpp)


## C. Точки сочленения

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан неориентированный граф. Требуется найти все точки сочленения в нём.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количества вершин и рёбер графа соответственно (1 ≤ _n_ ≤ 20 000, 1 ≤ _m_ ≤ 200 000).

Следующие _m_ строк содержат описание рёбер по одному на строке. Ребро номер _i_ описывается двумя натуральными числами _bi_, _ei_ — номерами концов ребра (1 ≤ _bi_, _ei_ ≤ _n_).

### Выходные данные

Первая строка выходного файла должна содержать одно натуральное число _b_ — количество точек сочленения в заданном графе. На следующей строке выведите _b_ целых чисел — номера вершин, которые являются точками сочленения, в возрастающем порядке.

### Примеры

**входные данные**
```c++
6 7
1 2
2 3
2 4
2 5
4 5
1 3
3 6
```
**выходные данные**
```c++
2
2 3 
```

### [Решение](C.cpp)


## D. Компоненты реберной двусвязности

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Компонентой реберной двусвязности графа  〈 _V_,_E_ 〉 называется подмножество вершин _S_ ⊂ _V_, такое что для любых различных _u_ и _v_ из этого множества существует не менее двух реберно не пересекающихся путей из _u_ в _v_.

Дан неориентированный граф. Требуется выделить компоненты реберной двусвязности в нем.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количества вершин и ребер графа соответственно (1  ≤  _n_  ≤  20 000, 1  ≤  _m_  ≤  200 000).

Следующие _m_ строк содержат описание ребер по одному на строке. Ребро номер _i_ описывается двумя натуральными числами _bi_, _ei_ — номерами концов ребра (1 ≤ _bi_, _ei_ ≤ _n_).

### Выходные данные

В первой строке выходного файла выведите целое число _k_ — количество компонент реберной двусвязности графа. Во второй строке выведите n натуральных чисел _a1_, _a2_, ..., _an_, не превосходящих _k_, где _ai_ — номер компоненты реберной двусвязности, которой принадлежит _i_-я вершина.

### Примеры

**входные данные**
```c++
6 7
1 2
2 3
3 1
1 4
4 5
4 6
5 6
```
**выходные данные**
```c++
2
1 1 1 2 2 2
```

### [Решение](D.cpp)


## E. Компоненты вершинной двусвязности

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Компонентой вершинной двусвязности графа 〈 _V_,_E_ 〉 называется максимальный по включению подграф (состоящий из вершин и ребер), такой что любые два ребра из него лежат на вершинно простом цикле.

Дан неориентированный граф без петель. Требуется выделить компоненты вершинной двусвязности в нем.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количества вершин и ребер графа соответственно (1 ≤ _n_ ≤ 20 000, 1 ≤ _m_ ≤ 200 000).

Следующие _m_ строк содержат описание ребер по одному на строке. Ребро номер _i_ описывается двумя натуральными числами _bi_, _ei_ — номерами концов ребра (1 ≤ _bi_, _ei_ ≤ _n_).

### Выходные данные

В первой строке выходного файла выведите целое число _k_ — количество компонент вершинной двусвязности графа. Во второй строке выведите m натуральных чисел _a1_, _a2_, ..., _am_, не превосходящих _k_, где _ai_ — номер компоненты вершинной двусвязности, которой принадлежит _i_-е ребро. Ребра нумеруются с единицы в том порядке, в котором они заданы во входном файле.

### Примеры

**входные данные**
```c++
5 6
1 2
2 3
3 1
1 4
4 5
5 1
```
**выходные данные**
```c++
2
1 1 1 2 2 2 
```

### [Решение](E.cpp)


## F. Конденсация графа

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Требуется найти количество ребер в конденсации ориентированного графа. Примечание: конденсация графа не содержит кратных ребер.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа соответственно (_n_ ≤ 10 000,  _m_ ≤ 100 000). Следующие _m_ строк содержат описание ребер, по одному на строке. Ребро номер _i_ описывается двумя натуральными числами _bi_, _ei_ — началом и концом ребра соответственно (1  ≤  _bi_,  _ei_  ≤  _n_). В графе могут присутствовать кратные ребра и петли.

### Выходные данные

Единственная строка выходного файла должна содержать одно число — количество ребер в конденсации графа.

### Примеры

**входные данные**
```c++
4 4
2 1
3 2
2 3
4 3
```
**выходные данные**
```c++
2 
```

### [Решение](F.cpp)


## G. Планирование вечеринки

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Петя планирует вечеринку, это дело непростое. Одна из главных проблем в том, что некоторые его друзья плохо ладят друг с другом, а некоторые — наоборот. В результате у него есть множество требований, например: «Я приду только если придет Гена» или «Если там будет Марина, то меня там точно не будет».

Петя формализовал все требования в следующем виде: «[+-]name1 => [+-]name2», здесь «name1» и «name2» — имена двух друзей Пети, «+» означает, что друг придет в гости, «-» — что не придет. Например, выражение «Если Андрея не будет, то Даша не придет» записывается так: «-andrey => -dasha».

Помогите Пете составить хоть какой-нибудь список гостей, удовлетворяющий всем свойствам, или скажите, что это невозможно

### Входные данные

В первой строке входного файла записаны числа _n_ и _m_ — число друзей Пети и число условий (1 ≤ _n_, _m_ ≤ 1000). В следующих _n_ строках записаны имена друзей. Имена друзей состоят из маленьких латинских букв и имеют длину не больше 10. В следующих m строках записаны условия.

### Выходные данные

Выведите в первой строке число _k_ — число друзей, которых нужно пригласить. В следующих _k_ строках выведите их имена.

### Примеры

**входные данные**
```c++
3 3
vova
masha
gosha
-vova => -masha
-masha => +gosha
+gosha => +vova
```
**выходные данные**
```c++
2
vova
masha
```

**входные данные**
```c++
1 1
vova
-vova => +vova
```
**выходные данные**
```c++
1
vova
```

**входные данные**
```c++
2 4
vova
masha
+vova => +masha
+masha => -vova
-vova => -masha
-masha => +vova
```
**выходные данные**
```c++
-1
```

### [Решение](G.cpp)


## H. Авиаперелеты

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: avia.in**
  
  **вывод: avia.out**
  
Главного конструктора Петю попросили разработать новую модель самолета для компании «Air Бубундия». Оказалось, что самая сложная часть заключается в подборе оптимального размера топливного бака.

Главный картограф «Air Бубундия» Вася составил подробную карту Бубундии. На этой карте он отметил расход топлива для перелета между каждой парой городов.

Петя хочет сделать размер бака минимально возможным, для которого самолет сможет долететь от любого города в любой другой (возможно, с дозаправками в пути).

### Входные данные

Первая строка входного файла содержит натуральное число _n_ (1 ≤ _n_ ≤ 1000) — число городов в Бубундии.

Далее идут _n_ строк по _n_ чисел каждая. _j_-ое число в _i_-ой строке равно расходу топлива при перелете из _i_-ого города в _j_-ый. Все числа не меньше нуля и меньше 10^9. Гарантируется, что для любого _i_ в _i_-ой строчке _i_-ое число равно нулю.

### Выходные данные

Первая строка выходного файла должна содержать одно число — оптимальный размер бака.

### Примеры

**входные данные**
```c++
4
0 10 12 16
11 0 8 9
10 13 0 22
13 10 17 0
```
**выходные данные**
```c++
10
```

### [Решение](H.cpp)


## I. Остовное дерево

  ограничение по времени на тест: 4 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Даны точки на плоскости, являющиеся вершинами полного графа. Вес ребра равен расстоянию между точками, соответствующими концам этого ребра. Требуется в этом графе найти остовное дерево минимального веса.

### Входные данные

Первая строка входного файла содержит натуральное число _n_ — количество вершин графа (1 ≤ _n_ ≤ 10 000). Каждая из следующих _n_ строк содержит два целых числа _xi_, _yi_  — координаты _i_-й вершины ( - 10 000 ≤ _xi_, _yi_ ≤ 10 000). Никакие две точки не совпадают.

### Выходные данные

Первая строка выходного файла должна содержать одно вещественное число — вес минимального остовного дерева.

### Примеры

**входные данные**
```c++
2
0 0
1 1
```
**выходные данные**
```c++
1.4142135624
```

### [Решение](I.cpp)


## J. Остовное дерево 2

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Требуется найти в связном графе остовное дерево минимального веса.

### Входные данные

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — количество вершин и ребер графа соответственно. Следующие _m_ строк содержат описание ребер по одному на строке. Ребро номер _i_ описывается тремя натуральными числами _bi_, _ei_ и _wi_ — номера концов ребра и его вес соответственно (1 ≤ _bi_, _ei_ ≤ _n_, 0 ≤ _wi_ ≤ 100 000). _n_ ≤ 200 000, _m_ ≤ 200 000.

Граф является связным.

### Выходные данные

Первая строка выходного файла должна содержать одно натуральное число — вес минимального остовного дерева.

### Примеры

**входные данные**
```c++
4 4
1 2 1
2 3 2
3 4 5
4 1 4
```
**выходные данные**
```c++
7
```

### [Решение](J.cpp)


## K. Алгоритм двух китайцев

  ограничение по времени на тест: 6 секунд
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Вам дан взвешенный ориентированный граф, содержащий _n_ вершин и _m_ рёбер. Найдите минимально возможную сумму весов _n_ - 1 ребра, которые нужно оставить в графе, чтобы из вершины с номером 1 по этим ребрам можно было добраться до любой другой вершины.

### Входные данные

В первой строке даны два целых числа _n_ и _m_ (1 ≤ _n_ ≤ 1 000, 0 ≤ _m_ ≤ 10 000) — количество вершин и ребер в графе.

В следующих m строках даны ребра графа. Ребро описывается тройкой чисел _ai_, _bi_ и _wi_ (1 ≤ _ai_, _bi_ ≤ _n_;  - 10^9 ≤ _wi_ ≤ 10^9) — номер вершины, из которой исходит ребро, номер вершины, в которую входит ребро, и вес ребра.

### Выходные данные

Если нельзя оставить подмножество ребер так, чтобы из вершины с номером 1 можно было добраться до любой другой, в единственной строке выведите «NO».

Иначе, в первой строке выведите «YES», а во второй строке выведите минимальную возможную сумму весов ребер, которых необходимо оставить.

### Примеры

**входные данные**
```c++
2 1
2 1 10
```
**выходные данные**
```c++
NO
```

**входные данные**
```c++
4 5
1 2 2
1 3 3
1 4 3
2 3 2
2 4 2
```
**выходные данные**
```c++
YES
6
```

### [Решение](K.cpp)
