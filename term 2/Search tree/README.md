# Дерево поиска

# A. Простое двоичное дерево поиска

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 512 мегабайт

Реализуйте просто двоичное дерево поиска.

### Формат входных данных

Входной файл содержит описание операций с деревом, их количество не превышает 100. В каж-
дой строке находится одна из следующих операций:

* insert _x_ — добавить в дерево ключ _x_. Если ключxесть в дереве, то ничего делать не надо

* delete _x_ — удалить из дерева ключ _x_. Если ключаxв дереве нет, то ничего делать не надо

* exists _x_ — если ключ _x_ есть в дереве выведите «true», если нет «false»

* next _x_ — выведите минимальный элемент в дереве, строго больший _x_, или «none» если такого
нет

* prev _x_ — выведите максимальный элемент в дереве, строго меньший _x_, или «none» если такого
нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций exists,next,prev. Следуйте
формату выходного файла из примера.

### Пример

**стандартный ввод**
```c++
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**стандартный вывод**
```c++
true
false
5
3
none
3
```

### [Решение](A.cpp)

## B. Сбалансированное двоичное дерево поиска

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 512 мегабайт

Реализуйте сбалансированное двоичное дерево поиска.

### Формат входных данных

Входной файл содержит описание операций с деревом, их количество не превышает 10^5. В каж-
дой строке находится одна из следующих операций:

* insert _x_ — добавить в дерево ключ _x_. Если ключxесть в дереве, то ничего делать не надо

* delete _x_ — удалить из дерева ключ _x_. Если ключаxв дереве нет, то ничего делать не надо

* exists _x_ — если ключ _x_ есть в дереве выведите «true», если нет «false»

* next _x_ — выведите минимальный элемент в дереве, строго больший _x_, или «none» если такого
нет

* prev _x_ — выведите максимальный элемент в дереве, строго меньший _x_, или «none» если такого
нет

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю 10^9.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций exists,next,prev. Следуйте
формату выходного файла из примера.

### Пример

**стандартный ввод**
```c++
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```

**стандартный вывод**
```
true
false
5
3
none
3
```

## C. Декартово дерево

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Вам даны пары чисел (_ai_, _bi_). Необходимо построить декартово дерево, такое что _i_-я вершина
имеет ключи (_ai_, _bi_), вершины с ключом _ai_ образуют бинарное дерево поиска, а вершины с ключом _bi_
образуют кучу.

### Формат входных данных

В первой строке записано число _N_ — количество пар. Далее следует _N_ ( 1 ⩽ _N_ ⩽ 300 000) пар
(_ai_, _bi_). Для всех пар |_ai_|; |_bi_| ⩽ 30 000. _ai̸=aj_ и _bi̸=bj_ для всех _i̸=j_ .

### Формат выходных данных

Если декартово дерево с таким набором ключей построить возможно, выведите в первой стро-
ке «YES», в противном случае выведите «NO». В случае ответа «YES» выведите _N_ строк, каждая
из которых должна описывать вершину. Описание вершины состоит из трёх чисел: номера предка,
номера левого сына и номера правого сына. Если у вершины отсутствует предок или какой либо
из сыновей, выведите на его месте число 0.
Если подходящих деревьев несколько, выведите любое.

### Пример

**стандартный ввод**
```с++
7
5 4
2 2
3 9
0 5
1 3
6 6
4 11
```

**стандартный вывод**
```c++
YES
2 3 6
0 5 1
1 0 7
5 0 0
2 4 0
1 0 0
3 0 0
```

### [Решение](C.cpp)

## D. Добавление ключей

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Вы работаете в компании Макрохард и вас попросили реализовать структуру данных, которая
будет хранить множество целых ключей.
Будем считать, что ключи хранятся в бесконечном массиве _A_, проиндексированном с 1 , исходно
все его ячейки пусты. Структура данных должна поддерживать следующую операцию:
Insert(_L_,_K_), где _L_ — позиция в массиве, а _K_ — некоторое положительное целое число.
Операция должна выполняться следующим образом:


* Если ячейка _A_[_L_] пуста, присвоить _A_[_L_] <- _K_.

* Если _A_[_L_] непуста, выполнить Insert(_L_+ 1,_A_[_L_]) и затем присвоить _A_[_L_] <- _K_.

По заданным _N_ целым числам _L1_, _L2_,...,_LN_ выведите массив после выполнения последователь
ности операций:
Insert(_L1_ , 1 )
Insert(_L2_ , 2 )
...
Insert(_LN_,_N_)

### Формат входных данных

Первая строка входного файла содержит числа _N_ — количество операций Insert, которое
следует выполнить и _M_ — максимальную позицию, которая используется в операциях Insert
( 1 ⩽ _N_ ⩽ 131 072, 1 ⩽ _M_ ⩽ 131 072).
Следующая строка содержит _N_ целых чисел _Li_, которые описывают операции Insert, которые
следует выполнить ( 1 ⩽ _Li_ ⩽ _M_).

### Формат выходных данных

Выведите содержимое массива после выполнения всех сделанных операций Insert. На первой
строке выведите _W_ — номер максимальной непустой ячейки в массиве. Затем выведите _W_ целых
чисел — _A_[1], _A_[2],..., _A_[_W_]. Выводите нули для пустых ячеек.

### Пример

**стандартный ввод**
```c++
5 4
3 3 4 1 3
```

**стандартный вывод**
```c++
6
4 0 5 2 3 1
```

### [Решение](D.cpp)

# E. И снова сумма

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 3 секунды

Ограничение по памяти: 256 мегабайт

Реализуйте структуру данных, которая поддерживает множество _S_ целых чисел, с котором раз-
решается производить следующие операции:

* add(_i_)— добавить в множество _S_ число _i_ (если он там уже есть, то множество не меняется);

* sum(_l_, _r_) — вывести сумму всех элементов _x_ из _S_, которые удовлетворяют неравенству
_l_ ⩽ _x_ ⩽ _r_.

### Формат входных данных

Исходно множество _S_ пусто. Первая строка входного файла содержит _n_ — количество операций
( 1 ⩽ _n_ ⩽ 300 000).Следующие _n_ строк содержат операции. Каждая операция имеет вид либо «+_i_»,
либо «? _l_ _r_». Операция «? _l_ _r_» задает запрос sum(_l_, _r_).
Если операция « +_i_ » идет во входном файле в начале или после другой операции «+», то она
задает операцию add(_i_). Если же она идет после запроса «?», и результат этого запроса былy, то
выполняется операция add((_i_ + _y_) mod 10^9 ).
Во всех запросах и операциях добавления параметры лежат в интервале от 0 до 10^9.

### Формат выходных данных

Для каждого запроса выведите одно число — ответ на запрос.

### Пример

**стандартный ввод**
```c++
6
+ 1
+ 3
+ 3
? 2 4
+ 1
? 2 4
```

**стандартный вывод**
```c++
3
7
```

### [Решение](E.cpp)

# F. K-й максимум

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 512 мегабайт

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять эле-
менты, а также находить _k_-й максимум.

### Формат входных данных

Первая строка входного файла содержит натуральное число _n_ — количество команд
(_n_ ⩽ 100 000). Последующиеnстрок содержат по одной команде каждая. Команда записывается в
виде двух чиселc _i_ и _ki_ — тип и аргумент команды соответственно (|ki| ⩽ 10^9 ). Поддерживаемые
команды:

* +1 (или просто 1 ): Добавить элемент с ключом _ki_.

* 0 : Найти и вывести _ki_-й максимум.

* -1 : Удалить элемент с ключом _ki_.

Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными
ключами или удалять несуществующие элементы. Также гарантируется, что при запросе _ki_-го мак-
симума, он существует.

### Формат выходных данных

Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержа-
щая единственное число — _ki_-й максимум.

### Пример

**стандартный ввод**
```
11
+1 5
+1 3
+1 7
0 1
0 2
0 3
-1 5
+1 10
0 1
0 2
0 3
```

**стандартный вывод**
```c++
7
5
3
10
7
3
```

### [Решение](F.cpp)

## G. Переместить в начало

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 6 секунд

Ограничение по памяти: 512 мегабайт

Вам дан массив _a1_ = 1; _a2_ = 2,..., _an_ = _n_ и последовальность операций: переместить элементы
с _li_ по _ri_ в начало массива. Например, для массива 2, 3, 6, 1, 5, 4 , после операции (2,4) новый по-
рядок будет 3, 6, 1, 2, 5, 4. А после применения операции (3,4) порядок элементов в массиве будет
1, 2, 3, 6, 5, 4.
Выведите порядок элементов в массиве после выполнения всех операций.

### Формат входных данных

В первой строке входного файла указаны числа _n_ и _m_ ( 2 ⩽ _n_ ⩽100 000, 1 ⩽ _m_ ⩽100 000) —
число элементов в массиве и число операций. Следующие _m_ строк содержат операции в виде двух
целых чисел: _li_ и _ri_ ( 1 ⩽ _li_ ⩽ _ri_ ⩽ _n_ ).

### Формат выходных данных

Выведите _n_ целых чисел — порядок элементов в массиве после применения всех операций.

### Пример

**стандартный ввод**
```c++
6 3
2 4
3 5
2 2
```

**стандартный вывод**
```c++
1 4 5 2 3 6
```

### [Решение](G.cpp)

## H. Различные буквы

Имя входного файла: log.in

Имя выходного файла: log.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Вы работаете со списком из строчных латинских букв. Изначально список пуст. Вы должны
поддерживать следующие операции:

* insert ⟨_index_⟩ ⟨_number_⟩ ⟨_letter_⟩ — добавить ⟨_number_⟩ букв ⟨_letter_⟩ перед буквой с индексом 
⟨_index_⟩.

* remove ⟨_index_⟩ ⟨_number_⟩ — удалить ⟨_number_⟩ букв, начиная с индекса ⟨_index_⟩.

* query ⟨_index_ 1 ⟩ ⟨_index_ 2 ⟩ — вывести количество различных букв на отрезке с ⟨_index_ 1 ⟩ до
⟨_index_ 2 ⟩включительно.

Буквы нумеруются с 1.

### Формат входных данных

В первой строке входного файла содержится единственное целое число _n_ — количество операций
( 1 ⩽ _n_ ⩽ 30 000). Следующие по _n_ строк содержат описание операций.
Описание операции начинается с типа операции: '+' для добавления, '-' для удаления и '?' для
запроса. Дальше следует аргументы запроса, описанные в условиях выше.
Все запросы корректны, элементы с такими индексами существуют, нет запросов на удаление
несуществующих элементов.
⟨_number_⟩ добавления, удаления не превышает 10 000.

### Формат выходных данных

Для каждого запроса **query** выведите одно целое число — количество различных букв на отрезке 
⟨_index_ 1 ⟩, ⟨_index_ 2 ⟩ включительно.

### Пример

**log.in**
```c++
8
+ 1 4 w
+ 3 3 o
? 2 3
- 2 2
? 2 3
+ 2 2 t
? 1 6
- 1 6
```

**log.out**
```c++
2
1
3
```

### Замечание
Пояснение к примеру:
1. wwww
2. wwoooww
3. w[wo]ooww: 2 различные буквы
4. wooww
5. w[oo]ww: 1 буква
6. wttooww
7. [wttoow]w: 3 различные буквы
8. w

## I. Эх, дороги

Имя входного файла: roads.in

Имя выходного файла: roads.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

В многострадальном Тридесятом государстве опять готовится дорожная реформа. Впрочем, на-
до признать, дороги в этом государстве находятся в довольно плачевном состоянии. Так что реформа
не повредит. Одна проблема — дорожникам не развернуться, поскольку в стране действует жесткий
закон — из каждого города должно вести не более двух дорог. Все дороги в государстве двусторон-
ние, то есть по ним разрешено движение в обоих направлениях (разумеется, разметка отсутствует).
В результате реформы некоторые дороги будут строиться, а некоторые другие закрываться на бес-
срочный ремонт.
Петя работает диспетчером в службе грузоперевозок на дальние расстояния. В связи с предстоя-
щими реформами, ему необходимо оперативно определять оптимальные маршруты между городами
в условиях постоянно меняющейся дорожной ситуации. В силу большого количества пробок и со-
трудников дорожной полиции в городах, критерием оптимальности маршрута считается количество
промежуточных городов, которые необходимо проехать.
Помогите Пете по заданной последовательности сообщений об изменении структуры дорог и за-
просам об оптимальном способе проезда из одного города в другой, оперативно отвечать на запросы.

### Формат входных данных

В первой строке входного файла заданы числа _n_ — количество городов, _m_ — количество дорог
в начале реформы и _q_ — количество сообщений об изменении дорожной структуры и запросов
( 1 ⩽ _n_, _m_ ⩽ 100 000, _q_ ⩽ 200 000). Следующие _m_ строк содержат по два целых числа каждая — пары
городов, соединенных дорогами перед реформой. Следующие _q_ строк содержат по три элемента,
разделенных пробелами. «+_i_ _j_ » означает строительство дороги от города _i_ до города _j_, «-_i_ _j_ »
означает закрытие дороги от города _i_ до города _j_, «? _i_ _j_ » означает запрос об оптимальном пути
между городами _i_ и _j_.
Гарантируется, что в начале и после каждого изменения никакие два города не соединены более
чем одной дорогой, и из каждого города выходит не более двух дорог. Никакой город не соединяется
дорогой сам с собой.

### Формат выходных данных

На каждый запрос вида «? _i_ _j_ » выведите одно число — минимальное количество промежуточ-
ных городов на маршруте из города _i_ в город _j_. Если проехать из _i_ в _j_ невозможно, выведите 
-1.

### Пример

**roads.in**
```c++
5 4 6
1 2
2 3
1 3
4 5
? 1 2
? 1 5
- 2 3
? 2 3
+ 2 4
? 1 5
```

**roads.out**
```c++
0
-1
1
2
```
